From c9e6192bb4ad6abab986c852cb3bc485f33d5294 Mon Sep 17 00:00:00 2001
From: Oleksii Moisieiev <oleksii_moisieiev@epam.com>
Date: Fri, 3 May 2024 16:13:51 +0300
Subject: [PATCH 11/21] drivers: reset: introduce reset drivers for brcmstb

Introducing Generic Reset controller and Generic RESCAL
drivers for Broadcom boards.

Signed-off-by: Oleksii Moisieiev <oleksii_moisieiev@epam.com>
Reviewed-by: Volodymyr Babchuk <volodymyr_babchuk@epam.com>
Signed-off-by: appkins <nbatkins@gmail.com>
---
 drivers/reset/Kconfig                |  14 ++++
 drivers/reset/Makefile               |   2 +
 drivers/reset/reset-brcmstb-rescal.c | 103 +++++++++++++++++++++++++++
 drivers/reset/reset-brcmstb.c        |  97 +++++++++++++++++++++++++
 4 files changed, 216 insertions(+)
 create mode 100644 drivers/reset/reset-brcmstb-rescal.c
 create mode 100644 drivers/reset/reset-brcmstb.c

diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index fe5c1214f57..cabb9dafe17 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -63,6 +63,20 @@ config RESET_BCM6345
 	help
 	  Support reset controller on BCM6345.
 
+config RESET_BRCMSTB
+	bool "Generic Reset controller driver for Broadcom"
+	help
+	  This enables reset controller for Broadcom devices.
+	  If you wish to use reset resources managed by the Broadcom
+	  Reset Controller, say Y here. Otherwise, say N.
+
+config RESET_BRCMSTB_RESCAL
+	bool "Generic Rescal Reset controller driver for Broadcom"
+	help
+	  Support rescal reset controller on Broadcom.
+	  If you wish to use reset resources managed by the Broadcom
+	  Reset Controller, say Y here. Otherwise, say N.
+
 config RESET_UNIPHIER
 	bool "Reset controller driver for UniPhier SoCs"
 	depends on ARCH_UNIPHIER
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index d99a78c9828..8f926c52c42 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -13,6 +13,8 @@ obj-$(CONFIG_TEGRA186_RESET) += tegra186-reset.o
 obj-$(CONFIG_RESET_TI_SCI) += reset-ti-sci.o
 obj-$(CONFIG_RESET_HSDK) += reset-hsdk.o
 obj-$(CONFIG_RESET_BCM6345) += reset-bcm6345.o
+obj-$(CONFIG_RESET_BRCMSTB) += reset-brcmstb.o
+obj-$(CONFIG_RESET_BRCMSTB_RESCAL) += reset-brcmstb-rescal.o
 obj-$(CONFIG_RESET_UNIPHIER) += reset-uniphier.o
 obj-$(CONFIG_RESET_AST2500) += reset-ast2500.o
 obj-$(CONFIG_RESET_AST2600) += reset-ast2600.o
diff --git a/drivers/reset/reset-brcmstb-rescal.c b/drivers/reset/reset-brcmstb-rescal.c
new file mode 100644
index 00000000000..fc8fcfa8b3f
--- /dev/null
+++ b/drivers/reset/reset-brcmstb-rescal.c
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Broadcom STB generic reset controller
+ *
+ * Copyright (C) 2024 EPAM Systems
+ * Moved from linux kernel:
+ * Copyright (C) 2018-2020 Broadcom
+ */
+
+#include <asm/io.h>
+#include <dm.h>
+#include <dm/device_compat.h>
+#include <errno.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/iopoll.h>
+#include <log.h>
+#include <malloc.h>
+#include <reset-uclass.h>
+
+#define BRCM_RESCAL_START 0x0
+#define BRCM_RESCAL_START_BIT BIT(0)
+#define BRCM_RESCAL_CTRL 0x4
+#define BRCM_RESCAL_STATUS 0x8
+#define BRCM_RESCAL_STATUS_BIT BIT(0)
+
+struct brcm_rescal_reset {
+	void __iomem *base;
+};
+
+/* Also doubles a deassert */
+static int brcm_rescal_reset_set(struct reset_ctl *rst)
+{
+	struct brcm_rescal_reset *data = dev_get_priv(rst->dev);
+	void __iomem *base = data->base;
+	u32 reg;
+	int ret;
+
+	reg = readl(base + BRCM_RESCAL_START);
+	writel(reg | BRCM_RESCAL_START_BIT, base + BRCM_RESCAL_START);
+	reg = readl(base + BRCM_RESCAL_START);
+	if (!(reg & BRCM_RESCAL_START_BIT)) {
+		dev_err(rst->dev, "failed to start SATA/PCIe rescal\n");
+		return -EIO;
+	}
+
+	ret = readl_poll_timeout(base + BRCM_RESCAL_STATUS, reg,
+				 (reg & BRCM_RESCAL_STATUS_BIT), 100);
+	if (ret) {
+		dev_err(rst->dev, "time out on SATA/PCIe rescal\n");
+		return ret;
+	}
+
+	reg = readl(base + BRCM_RESCAL_START);
+	writel(reg & ~BRCM_RESCAL_START_BIT, base + BRCM_RESCAL_START);
+
+	dev_dbg(rst->dev, "SATA/PCIe rescal success\n");
+	return 0;
+}
+
+/* A dummy function - deassert/reset does all the work */
+static int brcm_rescal_reset_assert(struct reset_ctl *rst)
+{
+	return 0;
+}
+
+static int brcm_rescal_reset_xlate(struct reset_ctl *reset_ctl,
+				   struct ofnode_phandle_args *args)
+{
+	/* This is needed if #reset-cells == 0. */
+	return 0;
+}
+
+static const struct reset_ops brcm_rescal_reset_ops = {
+	.rst_deassert = brcm_rescal_reset_set,
+	.rst_assert = brcm_rescal_reset_assert,
+	.of_xlate = brcm_rescal_reset_xlate,
+};
+
+static int brcm_rescal_reset_probe(struct udevice *dev)
+{
+	struct brcm_rescal_reset *data = dev_get_priv(dev);
+
+	data->base = dev_remap_addr(dev);
+	if (!data->base)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const struct udevice_id brcm_rescal_reset_of_match[] = {
+	{.compatible = "brcm,bcm7216-pcie-sata-rescal"},
+	{},
+};
+
+U_BOOT_DRIVER(brcmstb_reset_rescal) = {
+	.name = "brcmstb-reset-rescal",
+	.id = UCLASS_RESET,
+	.of_match = brcm_rescal_reset_of_match,
+	.ops = &brcm_rescal_reset_ops,
+	.probe = brcm_rescal_reset_probe,
+	.priv_auto = sizeof(struct brcm_rescal_reset),
+};
diff --git a/drivers/reset/reset-brcmstb.c b/drivers/reset/reset-brcmstb.c
new file mode 100644
index 00000000000..7861f7c9baf
--- /dev/null
+++ b/drivers/reset/reset-brcmstb.c
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Broadcom STB generic reset controller
+ *
+ * Copyright (C) 2024 EPAM Systems
+ *
+ * Moved from linux kernel:
+ * Author: Florian Fainelli <f.fainelli@gmail.com>
+ * Copyright (C) 2018 Broadcom
+ */
+
+#include <asm/io.h>
+#include <dm.h>
+#include <errno.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <log.h>
+#include <malloc.h>
+#include <reset-uclass.h>
+
+struct brcmstb_reset {
+	void __iomem *base;
+};
+
+#define SW_INIT_SET 0x00
+#define SW_INIT_CLEAR 0x04
+#define SW_INIT_STATUS 0x08
+
+#define SW_INIT_BIT(id) BIT((id) & 0x1f)
+#define SW_INIT_BANK(id) ((id) >> 5)
+
+#define usleep_range(a, b) udelay((b))
+
+/* A full bank contains extra registers that we are not utilizing but still
+ * qualify as a single bank.
+ */
+#define SW_INIT_BANK_SIZE 0x18
+
+static int brcmstb_reset_assert(struct reset_ctl *rst)
+{
+	unsigned int off = SW_INIT_BANK(rst->id) * SW_INIT_BANK_SIZE;
+	struct brcmstb_reset *priv = dev_get_priv(rst->dev);
+
+	writel_relaxed(SW_INIT_BIT(rst->id), priv->base + off + SW_INIT_SET);
+	return 0;
+}
+
+static int brcmstb_reset_deassert(struct reset_ctl *rst)
+{
+	unsigned int off = SW_INIT_BANK(rst->id) * SW_INIT_BANK_SIZE;
+	struct brcmstb_reset *priv = dev_get_priv(rst->dev);
+
+	writel_relaxed(SW_INIT_BIT(rst->id), priv->base + off + SW_INIT_CLEAR);
+	/* Maximum reset delay after de-asserting a line and seeing block
+	 * operation is typically 14us for the worst case, build some slack
+	 * here.
+	 */
+	usleep_range(100, 200);
+	return 0;
+}
+
+static int brcmstb_reset_status(struct reset_ctl *rst)
+{
+	unsigned int off = SW_INIT_BANK(rst->id) * SW_INIT_BANK_SIZE;
+	struct brcmstb_reset *priv = dev_get_priv(rst->dev);
+
+	return readl_relaxed(priv->base + off + SW_INIT_STATUS) &
+			SW_INIT_BIT(rst->id);
+}
+
+struct reset_ops brcmstb_reset_reset_ops = {
+	.rst_assert = brcmstb_reset_assert,
+	.rst_deassert = brcmstb_reset_deassert,
+	.rst_status = brcmstb_reset_status};
+
+static int brcmstb_reset_probe(struct udevice *dev)
+{
+	struct brcmstb_reset *priv = dev_get_priv(dev);
+
+	priv->base = dev_remap_addr(dev);
+	if (!priv->base)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const struct udevice_id brcmstb_reset_ids[] = {
+	{.compatible = "brcm,brcmstb-reset"}, {/* sentinel */}};
+
+U_BOOT_DRIVER(brcmstb_reset) = {
+	.name = "brcmstb-reset",
+	.id = UCLASS_RESET,
+	.of_match = brcmstb_reset_ids,
+	.ops = &brcmstb_reset_reset_ops,
+	.probe = brcmstb_reset_probe,
+	.priv_auto = sizeof(struct brcmstb_reset),
+};
-- 
2.52.0

