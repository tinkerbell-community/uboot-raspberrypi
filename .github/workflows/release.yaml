name: Build and Release U-Boot Raspberry Pi Image

on:
  workflow_dispatch:
    inputs:
      uboot_version:
        description: "U-Boot version tag to build"
        required: false
        default: "v2026.01"
        type: string
      rpi_firmware_version:
        description: "Raspberry Pi firmware version"
        required: false
        default: "next"
        type: string
  push:
    tags:
      - 'v*'

env:
  UBOOT_VERSION: ${{ inputs.uboot_version || 'v2026.01' }}
  UBOOT_DIR: ${{ github.workspace }}/u-boot
  RPI_FIRMWARE_VERSION: ${{ inputs.rpi_firmware_version || 'next' }}
  TALOS_KERNEL_VERSION: ghcr.io/siderolabs/kernel:v1.12.0-32-g4f8efaf

jobs:
  determine-version:
    runs-on: ubuntu-latest
    outputs:
      release_version: ${{ steps.version.outputs.release_version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required to get all tags
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest tag with U-Boot version prefix
        id: previoustag
        uses: WyriHaximus/github-action-get-previous-tag@v1
        continue-on-error: true
        with:
          prefix: ${{ env.UBOOT_VERSION }}

      - name: Calculate next version
        id: version
        run: |
          UBOOT_VER="${{ env.UBOOT_VERSION }}"

          # Check if we got a previous tag
          if [ "${{ steps.previoustag.outcome }}" == "success" ] && [ -n "${{ steps.previoustag.outputs.tag }}" ]; then
            PREV_TAG="${{ steps.previoustag.outputs.tag }}"
            echo "Found previous tag: $PREV_TAG"

            # Extract version numbers (remove 'v' prefix if present)
            PREV_VERSION="${PREV_TAG#v}"

            # Split into parts
            IFS='.' read -ra PARTS <<< "$PREV_VERSION"
            MAJOR="${PARTS[0]}"
            MINOR="${PARTS[1]}"
            PATCH="${PARTS[2]:-0}"

            # Increment patch version
            NEW_PATCH=$((PATCH + 1))
            RELEASE_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"

            echo "Incremented from $PREV_VERSION to $RELEASE_VERSION"
          else
            # No previous tag found, start with .0
            RELEASE_VERSION="${UBOOT_VER#v}.0"
            echo "No previous tag found, starting with $RELEASE_VERSION"
          fi

          echo "release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "Final release version: $RELEASE_VERSION"

  build-uboot:
    needs: determine-version
    runs-on: ubuntu-24.04-arm
    strategy:
      matrix:
        config:
          - name: rpi_arm64
            path: u-boot.bin
          - name: rpi_5
            path: u-boot-rpi5.bin
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          path: src
          ref: ${{ github.ref }}

      - name: Checkout u-boot
        uses: actions/checkout@v4
        with:
          repository: u-boot/u-boot
          fetch-depth: 1
          path: u-boot
          ref: ${{ env.UBOOT_VERSION }}

      - name: Cache and install build dependencies
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: build-essential git bison flex bc libssl-dev libgnutls28-dev device-tree-compiler
          version: 1.0

      - name: Configure U-Boot for Raspberry Pi 4 ARM64
        working-directory: u-boot
        run: |
          patch -p1 < ${{ github.workspace }}/src/patches/${{ matrix.config.name }}_defconfig.patch
          make ${{ matrix.config.name }}_defconfig

          echo "CONFIG_SERVERIP_FROM_PROXYDHCP=y" >> .config
          echo "CONFIG_BOOTP_SEND_HOSTNAME=y" >> .config
          echo "CONFIG_BOOTP_DNS2=y" >> .config
          echo "CONFIG_BOOTP_NTPSERVER=y" >> .config

      - name: Build U-Boot
        working-directory: u-boot
        run: |
          make -j $(nproc) HOSTLDLIBS_mkimage="-lssl -lcrypto"
          ls -la u-boot.bin

      - name: Rename U-Boot
        working-directory: u-boot
        if: ${{ matrix.config.path != 'u-boot.bin' }}
        run: |
          mv u-boot.bin ${{ matrix.config.path }}
          ls -la ${{ matrix.config.path }}

      - name: Upload U-Boot binary
        uses: actions/upload-artifact@v4
        with:
          name: uboot-binary-${{ matrix.config.name }}
          path: u-boot/${{ matrix.config.path }}
          retention-days: 1
          if-no-files-found: error

  checkout-firmware:
    needs: determine-version
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout Raspberry Pi firmware
        uses: actions/checkout@v4
        with:
          repository: raspberrypi/firmware
          fetch-depth: 1
          path: firmware
          ref: ${{ env.RPI_FIRMWARE_VERSION }}

      - name: Upload firmware
        uses: actions/upload-artifact@v4
        with:
          name: rpi-firmware
          path: |
            firmware/boot/
            !firmware/boot/kernel*
            !firmware/boot/bcm27*
          retention-days: 1
          if-no-files-found: error

  build-ipxe-arm64:
    needs: determine-version
    runs-on: ubuntu-24.04-arm
    permissions:
      contents: read
    steps:
      - name: Checkout repository
        id: checkout
        uses: actions/checkout@v4
        with:
          repository: ipxe/ipxe
          ref: master
          path: ipxe
          fetch-depth: 1

      - name: Cache and install build dependencies
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: build-essential git liblzma-dev
          version: 1.0

      - name: Get iPXE commit hash
        id: ipxe_commit
        working-directory: ipxe
        run: |
          commit_short=$(git rev-parse --short=7 HEAD)
          echo "commit_short=${commit_short}" >> $GITHUB_OUTPUT
          echo "iPXE commit: ${commit_short}"

      - name: Build iPXE for ARM64 Raspberry Pi
        working-directory: ipxe/src
        run: |
          # Create embedded script
          cat <<EOF | tee embedded.ipxe
          #!ipxe

          set user-class Tinkerbell
          echo Welcome to Neverland!

          :iterate-interfaces
          set idx:int32 0
          :interfaces-loop
          isset \${net\${idx}/ip} && goto interfaces-loop-done || iseq \${idx} 50 && goto autoboot || inc idx && goto interfaces-loop

          :interfaces-loop-done
          echo Booting from net\${idx}...
          set retry-max:int32 10
          set count:int32 1
          :retry-loop1
          echo trying dhcp ( attempt \${count}/\${retry-max} )
          dhcp net\${idx} && goto done1 || iseq \${count} \${retry-max} && goto done1 || inc count && goto retry-loop1
          :done1
          autoboot net\${idx} || exit 1

          :autoboot
          set retry-max:int32 10
          set count:int32 1
          :retry-loop2
          echo trying dhcp ( attempt \${count}/\${retry-max} )
          dhcp && goto done2 || iseq \${count} \${retry-max} && goto done2 || inc count && goto retry-loop2
          :done2
          autoboot || exit 1
          EOF

          # Create config file to enable TFTP
          cat <<EOF | tee config/rpi/general.h
          #define CERT_CMD              /* Certificate management commands */
          #define DIGEST_CMD            /* Image crypto digest commands */
          #define DOWNLOAD_PROTO_TFTP   /* Trivial File Transfer Protocol */
          #define DOWNLOAD_PROTO_HTTPS  /* Secure Hypertext Transfer Protocol */
          #define IMAGE_TRUST_CMD       /* Image trust management commands */
          #define NET_PROTO_IPV6        /* IPv6 protocol */
          #define NSLOOKUP_CMD          /* DNS resolving command */
          #define NTP_CMD               /* NTP commands */
          #define NVO_CMD               /* Non-volatile option storage commands */
          #define PARAM_CMD             /* params and param commands, for POSTing to tink */
          #define PING_CMD              /* Ping command */
          #define POWEROFF_CMD          /* Power off command */
          #define REBOOT_CMD            /* Reboot command */
          #define SANBOOT_PROTO_HTTP    /* HTTP SAN protocol */
          #define VLAN_CMD              /* VLAN commands */
          #define DOWNLOAD_PROTO_NFS    /* NFS */
          #define ROUTE_CMD             /* Routing table management commands */
          #define NET_PROTO_LACP        /* Link Aggregation control protocol */

          #undef CRYPTO_80211_WEP       /* WEP encryption (deprecated and insecure!) */
          #undef CRYPTO_80211_WPA2      /* Add support for stronger WPA cryptography */
          #undef CRYPTO_80211_WPA       /* WPA Personal, authenticating with passphrase */
          #undef FCMGMT_CMD             /* Fibre Channel management commands */
          #undef IBMGMT_CMD             /* Infiniband management commands */
          #undef IMAGE_PNG              /* PNG image support */
          #undef IMAGE_PNM              /* PNM image support */
          #undef IWMGMT_CMD             /* Wireless interface management commands */
          #undef NET_PROTO_STP          /* Spanning Tree protocol */
          #undef VNIC_IPOIB             /* Infiniband IPoIB virtual NICs */

          //defined in config/defaults/{efi,pcbios}.h and we don't want
          #undef SANBOOT_PROTO_AOE      /* AoE protocol */
          #undef SANBOOT_PROTO_FCP      /* Fibre Channel protocol */
          #undef SANBOOT_PROTO_IB_SRP   /* Infiniband SCSI RDMA protocol */
          #undef SANBOOT_PROTO_ISCSI    /* iSCSI protocol */
          #undef USB_EFI                /* Provide EFI_USB_IO_PROTOCOL interface */
          #undef USB_HCD_EHCI           /* EHCI USB host controller */
          #undef USB_HCD_UHCI           /* UHCI USB host controller */
          #undef USB_HCD_XHCI           /* xHCI USB host controller */
          #undef USB_KEYBOARD           /* USB keyboards */

          #undef NAP_EFIX86
          #undef NAP_EFIARM
          #define NAP_NULL
          EOF

          cat <<EOF | tee config/rpi/crypto.h
          #undef OCSP_CHECK
          EOF

          # Build with proper version variables
          make VERSION_MAJOR=1 VERSION_MINOR=21 VERSION_PATCH=1 EXTRAVERSION="+ (${{ steps.ipxe_commit.outputs.commit_short }})" CONFIG=rpi EMBED=embedded.ipxe -j $(nproc) bin-arm64-efi/snp.efi
          ls -lah bin-arm64-efi/snp.efi

      - name: Upload iPXE binary
        uses: actions/upload-artifact@v4
        with:
          name: ipxe-arm64-binary
          path: ipxe/src/bin-arm64-efi/snp.efi
          retention-days: 1
          overwrite: true
          if-no-files-found: error

  prepare-config:
    needs: determine-version
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload config.txt
        uses: actions/upload-artifact@v4
        with:
          name: config-files
          path: config.txt
          retention-days: 1
          overwrite: true
          if-no-files-found: error

  fetch-kernel-dts:
    needs: determine-version
    runs-on: ubuntu-24.04-arm
    permissions:
      contents: read

    steps:
      - name: Setup crane
        uses: imjasonh/setup-crane@v0.4

      - name: Extract device tree files from Talos kernel image
        run: |
          echo "Extracting DTBs from: ${{ env.TALOS_KERNEL_VERSION }}"

          # Create output directory
          mkdir -p kernel-dts

          # Export container filesystem and extract device tree files
          crane export --platform linux/arm64 ${{ env.TALOS_KERNEL_VERSION }} - | tar xz -C kernel-dts - --strip-components=2 dtb/broadcom

          # Filter to only bcm27* files (bcm2711 for Pi 4, bcm2712 for Pi 5) and move to top level
          find kernel-dts -type f -name 'bcm27*.dtb' -exec sh -c 'mv "$1" kernel-dts/$(basename "$1")' _ {} \;

          # Remove any extracted subdirectories
          find kernel-dts -mindepth 1 -type d -exec rm -rf {} + 2>/dev/null || true

          # Verify we got the files
          echo "Extracted device tree files:"
          ls -lah kernel-dts/

          if [ -z "$(ls -A kernel-dts/)" ]; then
            echo "ERROR: No bcm27* device tree files found"
            exit 1
          fi

      - name: Upload kernel device tree files
        uses: actions/upload-artifact@v4
        with:
          name: kernel-dts
          path: kernel-dts/
          retention-days: 1
          if-no-files-found: error

  build-image:
    needs: [determine-version, build-uboot, checkout-firmware, build-ipxe-arm64, prepare-config, fetch-kernel-dts]
    runs-on: ubuntu-24.04-arm
    permissions:
      contents: write
      packages: write
      id-token: write

    outputs:
      image_name: ${{ steps.create_image.outputs.image_name }}
      image_size: ${{ steps.create_image.outputs.image_size }}
      release_version: ${{ needs.determine-version.outputs.release_version }}

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Cache and install build dependencies
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: dosfstools parted xz-utils
          version: 1.0

      - name: Prepare build directory
        run: |
          mkdir -p build
          mkdir -p mnt
          mkdir -p out

          # Copy U-Boot binaries
          cp artifacts/uboot-*/*.bin build/
          ls -lah build/

          # Copy config file
          cp artifacts/config-files/config.txt build/

          # Copy firmware files
          cp -r artifacts/rpi-firmware/* build/

          # Copy upstream Talos kernel device tree files (bcm2712*)
          # These replace the downstream Pi firmware DTBs which are incompatible with mainline
          echo "Copying upstream Talos kernel device tree files..."
          cp artifacts/kernel-dts/* build/
          echo "Kernel DTB files:"
          ls -lah build/bcm2712*

          # Copy iPXE binary
          mkdir -p build/EFI/BOOT
          cp artifacts/ipxe-arm64-binary/snp.efi build/EFI/BOOT/BOOTAA64.EFI

          echo "Build directory contents:"
          ls -lah build/

      - name: Create SD card image
        id: create_image
        working-directory: out
        env:
          RELEASE_VERSION: ${{ needs.determine-version.outputs.release_version }}
        run: |
          # Calculate required size (boot files + 100MB padding)
          BOOT_SIZE=$(du -sm ../build | cut -f1)
          IMAGE_SIZE=$((BOOT_SIZE + 100))

          echo "Creating ${IMAGE_SIZE}MB image..."

          # Create image file with semantic version
          IMAGE_NAME="uboot-raspberrypi-${RELEASE_VERSION}.img"
          dd if=/dev/zero of="$IMAGE_NAME" bs=1M count=$IMAGE_SIZE status=progress

          # Create partition table with proper type for Pi 5
          # Use sfdisk to set partition type to 0x0c (W95 FAT32 LBA)
          cat > partition.sfdisk << 'SFDISK_EOF'
          label: dos
          unit: sectors
          sector-size: 512

          start=2048, type=c, bootable
          SFDISK_EOF

          sfdisk "$IMAGE_NAME" < partition.sfdisk

          # Setup loop device
          LOOP_DEVICE=$(sudo losetup --find --show --partscan "$IMAGE_NAME")
          echo "Loop device: $LOOP_DEVICE"

          # Format partition as FAT32 with explicit parameters
          sudo mkfs.vfat -F 32 -n BOOT "${LOOP_DEVICE}p1"

          # Mount and copy files
          sudo mount "${LOOP_DEVICE}p1" ../mnt
          sudo cp -rv ../build/* ../mnt/
          sudo sync
          sudo umount ../mnt

          # Cleanup
          sudo losetup -d "$LOOP_DEVICE"

          # Calculate checksums
          sha256sum "$IMAGE_NAME" > "${IMAGE_NAME}.sha256"

          # Get image info
          IMAGE_SIZE_BYTES=$(stat -c%s "$IMAGE_NAME")
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "image_size=$IMAGE_SIZE_BYTES" >> $GITHUB_OUTPUT

          ls -lh "$IMAGE_NAME"*

      - name: Compress image
        working-directory: out
        env:
          IMAGE_NAME: ${{ steps.create_image.outputs.image_name }}
        run: |
          echo "Compressing image..."
          xz -9 -T 0 "${IMAGE_NAME}"

          # Update checksum for compressed file
          sha256sum "${IMAGE_NAME}.xz" > "${IMAGE_NAME}.xz.sha256"

      - name: Create release notes
        working-directory: out
        env:
          RELEASE_VERSION: ${{ needs.determine-version.outputs.release_version }}
        run: |
          cat > release_notes.md << EOF
          # Raspberry Pi 4 U-Boot SD Card Image

          ## Components

          - **U-Boot Version**: \`${{ env.UBOOT_VERSION }}\`
          - **Release Version**: \`${RELEASE_VERSION}\`
          - **Raspberry Pi Firmware**: \`${{ env.RPI_FIRMWARE_VERSION }}\`
          - **Architecture**: ARM64 (aarch64)
          - **Target Device**: Raspberry Pi 4 / Raspberry Pi 400

          ## Features

          - PXE network boot support
          - DHCP client built-in
          - EFI boot support
          - USB storage boot
          - NVMe boot support (with patches)
          - iPXE network boot (snp.efi included)
          - Custom boot command for network-first boot

          ## Installation

          ### Using Raspberry Pi Imager

          1. Download \`${{ steps.create_image.outputs.image_name }}.xz\`
          2. Open Raspberry Pi Imager
          3. Choose "Use custom" and select the downloaded \`.xz\` file
          4. Select your SD card
          5. Write the image

          ### Using dd (Linux/macOS)

          \`\`\`bash
          # Decompress
          xz -d ${{ steps.create_image.outputs.image_name }}.xz

          # Write to SD card (replace /dev/sdX with your SD card device)
          sudo dd if=${{ steps.create_image.outputs.image_name }} of=/dev/sdX bs=4M status=progress
          sudo sync
          \`\`\`

          ## Boot Configuration

          The image includes a custom \`config.txt\` that:
          - Enables 64-bit ARM mode
          - Uses U-Boot as the kernel
          - Configures minimal GPU memory
          - Enables UART for debugging

          ## Boot Sequence

          The default boot order:
          1. Attempt USB disk boot (EFI)
          2. Attempt network boot via DHCP/PXE
          3. Fall back to local disk

          ## Verification

          Verify the image integrity:

          \`\`\`bash
          sha256sum -c ${{ steps.create_image.outputs.image_name }}.xz.sha256
          \`\`\`

          ## Image Information

          - **Uncompressed Size**: ${{ steps.create_image.outputs.image_size }} bytes
          - **Format**: Raw disk image (MBR partition table, FAT32 boot partition)

          ---

          *Built on $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
          EOF

          cat release_notes.md

      - name: Upload final artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rpi4-uboot-image
          path: |
            out/${{ steps.create_image.outputs.image_name }}.xz
            out/${{ steps.create_image.outputs.image_name }}.xz.sha256
            out/release_notes.md
          retention-days: 30

      - name: Report build status
        env:
          RELEASE_VERSION: ${{ needs.determine-version.outputs.release_version }}
        run: |
          echo "‚úÖ U-Boot SD card image created successfully"
          echo "üì¶ Image: ${{ steps.create_image.outputs.image_name }}.xz"
          echo "üìè Uncompressed size: ${{ steps.create_image.outputs.image_size }} bytes"
          echo "üîñ U-Boot version: ${{ env.UBOOT_VERSION }}"
          echo "üîñ Release version: ${RELEASE_VERSION}"
          echo "üîñ Firmware version: ${{ env.RPI_FIRMWARE_VERSION }}"

  publish-github-release:
    name: Publish GitHub Release
    needs: build-image
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: rpi4-uboot-image
          path: artifacts

      - name: Create or update GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.build-image.outputs.release_version }}
          name: Release v${{ needs.build-image.outputs.release_version }}
          body_path: artifacts/release_notes.md
          files: |
            artifacts/${{ needs.build-image.outputs.image_name }}.xz
            artifacts/${{ needs.build-image.outputs.image_name }}.xz.sha256
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish-oras:
    name: Publish to ORAS Registry
    needs: build-image
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: rpi4-uboot-image
          path: artifacts

      - name: Setup ORAS
        uses: oras-project/setup-oras@v1
        with:
          version: 1.2.0

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract version from tag or input
        id: extract_version
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            VERSION="${{ github.ref_name }}"
          else
            VERSION="v${{ needs.build-image.outputs.release_version }}"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Publishing version: ${VERSION}"

      - name: Push artifacts to ORAS
        working-directory: artifacts
        env:
          VERSION: ${{ steps.extract_version.outputs.version }}
        run: |
          # Convert repository name to lowercase for GHCR compatibility
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_BASE="ghcr.io/${REPO_LOWER}"

          echo "Publishing to: ${IMAGE_BASE}:${VERSION}"

          # Push all artifacts as a single OCI artifact
          oras push "${IMAGE_BASE}:${VERSION}" \
            --artifact-type application/vnd.tinkerbell.uboot.image.v1 \
            ${{ needs.build-image.outputs.image_name }}.xz:application/octet-stream \
            ${{ needs.build-image.outputs.image_name }}.xz.sha256:text/plain \
            release_notes.md:text/markdown

          echo "‚úÖ Published to ${IMAGE_BASE}:${VERSION}"

          # Also tag as latest if this is a release
          if [ "${{ github.event_name }}" = "push" ]; then
            oras tag "${IMAGE_BASE}:${VERSION}" latest
            echo "‚úÖ Tagged as latest"
          fi

      - name: Report ORAS publication
        env:
          VERSION: ${{ steps.extract_version.outputs.version }}
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "‚úÖ Artifacts published to ORAS registry"
          echo "üì¶ Registry: ghcr.io/${REPO_LOWER}"
          echo "üè∑Ô∏è  Version: ${VERSION}"
          echo ""
          echo "To pull the artifacts:"
          echo "  oras pull ghcr.io/${REPO_LOWER}:${VERSION}"
